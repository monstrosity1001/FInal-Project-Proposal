<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font Rendering Pipeline Proposal</title>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; line-height: 1.6; margin: 20px; }
        h1, h2 { color: #333; text-align: center; }
        h1 { font-size: 2em; }
        h2 { font-size: 1.5em; margin-top: 1em; }
        p { margin: 0.5em 0; }
        ul { margin: 0.5em 0; padding-left: 20px; }
        li { margin: 0.3em 0; }
        .container { margin: 0 auto; padding: 60px 20%; }
        figure { text-align: center; }
        img { display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Font Rendering Pipeline with CPU and GPU Rasterization</h1>
        <h2>Summary and Team Members</h2>
        <p><strong>Summary:</strong> This project will implement a rendering pipeline from a TrueType font (TTF) to high-quality, anti-aliased text on screen. We will parse TrueType outlines defined by Bézier curves, evaluate these curves to reconstruct each glyph's shape, and rasterize these shapes into quality pixel bitmaps using supersampling for anti-aliasing. Rasterization will utilize both CPU-based and experimental GPU-based approaches. By comparing the two, we aim to understand the performance differences and quality trade-offs in text rendering, focusing on producing sharp, anti-aliased glyphs for user interfaces and digital application documents.</p>
        <p><strong>Team Members:</strong> Vishal Bansal, Varun Mittal, Saatvik Billa</p>
        <h2>Problem Description</h2>
        <p>Generating high-quality text from vector font files is a key issue in computer graphics and digital typography. Contemporary fonts, such as TrueType and OpenType, depict each character (glyph) as a collection of mathematical curves and lines, typically Bézier curves, instead of using pre-rendered bitmaps. The challenge lies in transforming this vector representation into a transparent bitmap on the screen, a procedure known as font rasterization. This process is crucial since text is ubiquitous in user interfaces, games, and documents, and users anticipate that it will remain readable and visually appealing at any size or resolution.</p>
        <ul>
            <li><strong>Complex Outlines:</strong> TrueType fonts store a master outline for each glyph composed of line segments and quadratic Bézier curves. These outlines are resolution-independent and must be scaled to the target size and resolution. For example, a font's letter "A" is defined by a series of points and curves, not pixels. The font rasterizer must interpret these curves to determine which pixels should be lit. This involves evaluating quadratic Bézier equations (often using algorithms like de Casteljau's) to trace the outline shape at many points.</li>
            <li><strong>Anti-Aliasing:</strong> Naively converting the outline to pixels can result in jagged edges ("jaggies") because of aliasing. High-quality text requires anti-aliasing, which means smoothing edges by shading pixels partially according to how much of the pixel area is covered by the glyph shape. Anti-aliasing determines the grayscale value of each pixel by the percentage of the pixel covered by the glyph's shape, producing much smoother results than binary on/off pixels. Techniques like supersampling and even more advanced subpixel rendering (as used in Microsoft's ClearType technology) improve legibility by making edges appear smoother without losing sharpness. Implementing anti-aliasing adds complexity because the rasterizer must calculate coverage area accurately for each pixel on the edges of the glyph rather than a binary on/off approach.</li>
            <li><strong>Performance:</strong> Text rendering needs to be efficient. In a UI or game, hundreds or thousands of characters may be drawn, potentially at every frame. A CPU rasterizer must handle all these glyphs quickly. Scanning-converting curves and filling polygons can be CPU-intensive, especially for large font sizes or bodies of text. TrueType fonts often include hinting instructions (tiny programs in the font) to adjust outlines for small sizes (aligning strokes to the device pixel grid for clarity), which we have to handle, too.</li>
        </ul>
        <p>To tackle these challenges, our project will implement the pipeline in stages. We will start by analyzing the font file on the CPU, examining curves, and filling in pixels, similar to existing libraries like FreeType or stb_truetype. However, creating our code will help us learn more. The basic process of a font engine includes scaling the outline to the required size, adjusting for grid alignment (hinting), and filling in scanlines to create the bitmap. We will follow this process, excluding hinting: reading the outline points, scaling them to our desired resolution, and filling pixels to render the glyph. The scanline method involves going through the pixel rows to find where they intersect with the outline—many font renderers commonly use this technique for efficiency. We plan to use the well-known scanline algorithm to fill the polygon defined by the glyph outline, similar to what FreeType and Sean Barrett’s stb_truetype.h library do. This scanline rasterization method will help us determine the coverage of each pixel, row by row, effectively managing complex shapes with holes, like the interiors of "O" or "P", using the winding rule.</p>
        <p>When using the GPU, the project takes on an exploratory approach. Modern GPUs are good at handling many tasks at once, which means moving font rendering to the GPU could make text rendering faster, though it comes with challenges. We can't simply run the same scanline loop on the GPU. Instead, we use fragment or compute shaders, which let the GPU check if pixels are inside the outline of a glyph simultaneously. Essentially, we ask the GPU to determine if a pixel is within the shape or near its edge for smoother edges (anti-aliasing). One method is to transfer the glyph outline to the GPU as vector shapes (like triangles or control points as textures) to calculate coverage. Research like Mozilla's Pathfinder project shows that rasterizing curves on the GPU can improve performance significantly. Another option is to use signed distance fields (SDFs), which create a texture for text rendering. Still, they can blur corners at small distances, making direct GPU evaluation of Bézier curves a better choice. An interesting idea from Will Dobbie's vector textures method suggests that the GPU could render directly from the original vector data (Bézier curves) instead of relying on pre-made textures. While we might not apply his whole approach, this concept guides our exploration by highlighting the challenges and innovations of using the GPU, requiring new structures and shaders to compute anti-aliased coverage accurately while keeping performance high.</p>
        <p>In summary, we aim to render text from vector fonts accurately and efficiently. This is crucial since users quickly notice poor rendering quality (blurry or jagged text). The challenge lies in combining curve mathematics, shape-filling algorithms, and optimizing for speed, including potential GPU parallelization. By developing a CPU and GPU rasterizer, we seek insights into trade-offs and how GPU acceleration can enhance high-quality text rendering.</p>
        <h2>Goals and Deliverables</h2>
        <ul>
            <li><strong>TrueType Font Parser & Bézier Outlines:</strong> This module loads TTF files and extracts font details and shapes for each letter. It reads font tables like the "glyf" table, which holds point coordinates and curve instructions. The result is a list of shapes for each character: straight lines and quadratic Bézier curves (featuring a start point, an endpoint, and one control point). This creates a structure that represents the glyph path.</li>
            <li><strong>Bézier Curve Evaluator:</strong> This tool computes points on a Bézier curve, using the de Casteljau algorithm (for quadratic curves) or a direct formula. Utilizing control points from font outlines generates smooth contours. For a quadratic Bézier (P0, P1, P2), we can create a function that samples the curve at a suitable resolution, producing a series of points. This is useful for debugging small line segments and rasterization by finding curve intersections with scan lines. The evaluator ensures the glyph's shape is accurately represented.</li>
            <li><strong>CPU-Based Rasterizer:</strong> This software engine creates anti-aliased glyph bitmaps from glyph outlines. It employs a scanline filling or analytic coverage algorithm to convert shapes, calculating coverage for each pixel (0 to 100% coverage mapped to 0–255 grayscale). When rendering a glyph like 'A' at 100px, the output will have smooth edges, comparable to other font renderers. We will validate accuracy against FreeType outputs to check anti-aliasing effectiveness. The rasterizer will manage characters with multiple contours, such as 'O', using even-odd or non-zero winding fill rules. Deliverable: A program to read TTF characters and produce grayscale images or pixel arrays.</li>
            <li><strong>CPU Rasterization Interactive Demo:</strong> We will create a simple interactive demo, either as a GUI or web page, where users can select a font (or use a built-in one), type text, or choose a sample glyph to see the rasterized output of our CPU engine. The demo will allow users to toggle the outline overlay to view Bézier control points and resulting pixels. This will showcase the accuracy and quality of our pipeline across different glyphs and sizes, making our project presentation more engaging with real-time text rendering.</li>
            <li><strong>GPU-Based Rasterizer (Experimental):</strong> We plan to implement GPU-accelerated font rendering alongside the CPU path using WebGL (fragment shaders) or C++ with OpenGL/GLSL. We aim to have the GPU render glyph outlines and produce faster, anti-aliased bitmaps. One method involves using a fragment shader to determine if a pixel lies within the glyph using Bézier curve equations. Another option is to convert the glyph outline into small triangles, leveraging the GPU's speed in triangle rendering, although this may lead to coverage issues at the edges. We prefer a shader-based analytical approach when feasible. Deliverable: A prototype that renders a subset of glyphs using the GPU, with a toggle for comparing CPU and GPU results. This could be part of a demo with a checkbox labeled "Use GPU Rasterization" to switch rendering methods. If successful, the GPU output should closely match the CPU output visually, with only minor floating-point differences and improved performance for larger text sizes.</li>
            <li><strong>Comparison and Analysis:</strong> We will compare CPU and GPU implementations by measuring rendering speed, such as the time to rasterize a glyph or a page of text, and by displaying image quality side by side with screenshots. If discrepancies arise, we will analyze them, like variations in GPU shader coverage calculations. Performance benchmarks will include rendering long strings of text at various sizes, measuring frame rate or milliseconds per frame for both CPU and GPU. Results will be summarized in a brief report or table. The final deliverable is the data along with a short discussion.</li>
            <li><strong>Stretch Goal – Font Hinting or Layout:</strong> We aim to introduce enhanced font rendering features, such as hinting and layout, depending on time availability. Basic hinting would entail interpreting the TrueType bytecode instructions and adjusting the glyph outlines at smaller sizes to enhance legibility. This task is quite intricate, necessitating a small virtual machine to execute the font's instructions, making it a highly ambitious stretch goal. Alternatively, we might concentrate on glyph layout, ensuring text strings have appropriate kerning and line spacing. For instance, we would leverage the font's kerning table to fine-tune the positioning of specific pairs like "To" or "AV," allowing for a more natural appearance. An outcome for layout would be the ability of our demo to render not just individual glyphs but strings of text with accurate spacing. This improvement would transition our project from a basic glyph renderer to a functional text renderer. Even in the absence of full hinting, we can implement essential vertical metrics (ascender, descender, line height) and horizontal metrics (advance width, kerning) to effectively construct lines of text, showcasing a comprehensive grasp of the font rendering pipeline.</li>
        </ul>
        <p>Our primary deliverables are a working CPU-based font rasterizer with anti-aliasing, an attempted GPU-based rasterizer, and a demo and comparative analysis. We will also produce documentation (and a presentation) explaining our methods, showing results (images of rendered text), and discussing any insights or performance numbers gathered.</p>
        <h2>Schedule</h2>
        <p>We will execute the project over 4 weeks, with each week focused on a subset of tasks:</p>
        <ul>
            <li><strong>Week 1: Font Parsing –</strong> We will start by reading the font file format. By the week’s end, we want a component to open a TrueType (TTF) file and parse necessary tables for glyph outlines. This requires understanding the TTF structure (tables like maxp, loca, glyf, etc.). For a character (e.g., "A"), we will retrieve its outline points and instructions for connecting points into curves or lines. We'll write code to interpret the data: TrueType outlines have flags for "on-curve" or "off-curve"; consecutive off-curve points imply curves. The outcome is representing each glyph as contours of line segments and quadratic Bézier segments. We will verify this by outlining (e.g., using an OpenGL line loop or a Python plotting script) to ensure the shape is correct. By Week 1, we establish the pipeline foundation: loading and understanding vector outline data fonts.</li>
            <li><strong>Week 2: Bézier Curve Implementation and CPU Rasterizer MVP –</strong> This week, we will implement Bézier curve mathematics into a basic rasterization routine. Early, we'll compute points on quadratic Bézier curves (and cubic if needed for certain fonts), likely using uniform step sampling or the de Casteljau algorithm to subdivide curves until nearly straight. This will allow us a dense list of points to fill the shape. The initial rasterization (MVP – Minimum Viable Product) may not include anti-aliasing, focusing first on using a scanline algorithm to mark pixels inside the polygon. By mid-week, we expect coarse-filled shapes (aliased bitmaps). Then, we'll add anti-aliasing, possibly through supersampling or an analytic method to compute pixel polygon area overlap. By the end of Week 2, we aim to have the CPU rasterizer producing recognizable, filled glyph bitmaps with some smoothing, testing with simple characters (like "A", "O", "B") against existing library renders for alignment well.</li>
            <li><strong>Week 3: Optimization, Refinement, and GPU Prototype –</strong> In Week 3, we will enhance our CPU rasterizer for quality and speed while starting the GPU implementation. Refinements include improving high-quality anti-aliasing (possibly implementing gamma-correct blending or adjusting coverage calculations) and optimizing code (like moving from brute-force point-in-polygon checks to more efficient scanline fills or using integer arithmetic for edge calculations). We’ll profile the CPU rasterizer with longer text strings to identify bottlenecks. We’ll set up a WebGL2 context for the GPU on a web page or use OpenGL in C++ with GLSL shaders to render simple shapes. Our initial goal is to render a tessellated polygon of the glyph using contour points for triangulation, offloading the fill to the GPU. After achieving basic GPU rendering, we’ll incorporate anti-aliasing using methods like multisample anti-aliasing (MSAA) or a custom shader for per-pixel coverage. By the end of Week 3, we aim to have basic GPU-accelerated rendering functional for at least one glyph and be able to toggle between CPU and GPU, ensuring similar output. We will also collect preliminary performance data comparing CPU and GPU rasterization times for a glyph of size N same).</li>
            <li><strong>Week 4: Final Integration and Evaluation –</strong> This week focuses on bringing everything together, polishing the demo, and comparing outputs. We will complete GPU rasterizer work, ensuring it can process multiple texts and maintain output consistency with the CPU. The GPU path will be integrated into the interactive demo UI, allowing mode switching and side-by-side rendering. We'll implement nearly finished features like kerning and possibly basic hinting. After implementation, we will evaluate rendering various texts, measure frame rates, and capture screenshots for comparison. To realistically compare CPU vs GPU, we’ll create test cases, including the pangram "The quick brown fox jumps over the lazy dog" and sections of Lorem Ipsum at varied sizes. Additionally, we will prepare our presentation and final report, compiling the proposal into a webpage/PDF and ensuring the code repository is organized for submission. By the end of Week 4, we aim to have a fully functional project with both CPU and GPU rasterization operational, an informative demo, and data for discussion report.</li>
        </ul>
        <p>Throughout all weeks, we will use an iterative approach: building incrementally and testing as we go since each stage (parsing, curve eval, fill) depends on the correctness of the previous. Our schedule is aggressive but feasible, and we have identified the GPU portion as the most uncertain. We have scheduled it for the latter half but will adjust it if the earlier parts take longer.</p>
        <h2>Resources</h2>
        <p>To accomplish this project, we will utilize and reference a variety of resources:</p>
        <ul>
            <li><strong>Font Libraries and References:</strong> We will refer to FreeType (an open-source font renderer) and stb_truetype.h (a font rasterizer by Sean Barrett) as guides. FreeType is known for being small, efficient, and portable. While we won't use these libraries directly, they provide references for expected outcomes and algorithms. Notably, the scanline filling technique in stb_truetype will influence our CPU implementation. The TrueType specification from Apple and Microsoft will help us understand font file structure and hinting behavior.</li>
            <li><strong>Graphics APIs and Tools:</strong> We'll use OpenGL/GLSL or WebGL for the GPU part. For native applications, we'll use C++ with OpenGL 4.x for geometry or compute shaders. Alternatively, we may use WebGL 2.0 in an HTML page for easier demo distribution; it supports essential features (fragment shaders, multiple render targets), but does not have compute shaders. We’ll leverage shader programming for rasterization on the GPU, possibly using GLFW or SDL to create a window and OpenGL context in C++. Standard development tools include GitHub for version control and Visual Studio Code or CLion for coding (or a simple text editor and browser dev tools for WebGL). We might use image viewers or custom debug views to debug visual output needed.</li>
            <li><strong>Research Papers and Articles:</strong> We will cite relevant research to inform our approach. A key resource is Microsoft’s literature on ClearType; although subpixel rendering is beyond our scope, ClearType enhances understanding of advanced font rendering methods that prioritize clarity. Another valuable resource is Alois Zingl's paper “A Rasterizing Algorithm for Drawing Curves,” which details methods to efficiently rasterize quadratic and cubic Bézier curves by finding the nearest pixel to the curve, informing our optimizations for plotting curves nearly as fast as lines. Additionally, blog posts and articles on font rasterization are invaluable. For instance, the Handmade Network's principles.</li>
            <li><strong>Testing and Font Files:</strong> We will use various font files (readily available or open licensed) to test our pipeline. For instance, we could use the classic Liberation Sans or Arial for basic tests and a more decorative font to see how curves are handled. We will also use known test strings or patterns (like "Ag" or a string containing many different shapes) to ensure our rasterizer works for all cases (straight lines, curves, corners, holes in characters, etc.). Our resources include these font files and possibly existing raster images (from FreeType) for visual comparison.</li>
        </ul>
        <p>Leveraging the above resources—established libraries for reference, graphics APIs for implementation, research literature for techniques, and test materials for validation—we are well-equipped to execute the project. In our final report, we will document references (academic or online) to acknowledge where algorithms or insights came from, using the citation format as required. Overall, combining these tools and references will support us in building a robust font rendering pipeline and tackle the challenges outlined in the proposal.</p>
    </div>
</body>
</html>
